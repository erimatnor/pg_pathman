\set VERBOSITY terse
SET search_path = 'public';
CREATE EXTENSION pg_pathman;
CREATE SCHEMA test_nulls;
/* hash */
CREATE TABLE test_nulls.hash_rel (
	id		SERIAL PRIMARY KEY,
	value	INTEGER
);
INSERT INTO test_nulls.hash_rel (value)
	SELECT val FROM generate_series(1, 5) val;
SELECT create_hash_partitions('test_nulls.hash_rel', 'value', 3);
 create_hash_partitions 
------------------------
                      3
(1 row)

/* test creating null partition */
SELECT * FROM pathman_partition_list ORDER BY partition;
       parent        |       partition       | parttype | expr  | range_min | range_max 
---------------------+-----------------------+----------+-------+-----------+-----------
 test_nulls.hash_rel | test_nulls.hash_rel_0 |        1 | value |           | 
 test_nulls.hash_rel | test_nulls.hash_rel_1 |        1 | value |           | 
 test_nulls.hash_rel | test_nulls.hash_rel_2 |        1 | value |           | 
(3 rows)

INSERT INTO test_nulls.hash_rel (value) VALUES (NULL);
SELECT * FROM pathman_partition_list ORDER BY partition;
       parent        |        partition         | parttype | expr  | range_min | range_max 
---------------------+--------------------------+----------+-------+-----------+-----------
 test_nulls.hash_rel | test_nulls.hash_rel_0    |        1 | value |           | 
 test_nulls.hash_rel | test_nulls.hash_rel_1    |        1 | value |           | 
 test_nulls.hash_rel | test_nulls.hash_rel_2    |        1 | value |           | 
 test_nulls.hash_rel | test_nulls.hash_rel_null |        1 | value |           | 
(4 rows)

EXPLAIN (COSTS OFF) SELECT tableoid::REGCLASS, value
		FROM test_nulls.hash_rel WHERE value IS NULL;
              QUERY PLAN               
---------------------------------------
 Result
   ->  Append
         ->  Seq Scan on hash_rel_null
(3 rows)

SELECT tableoid::REGCLASS, value FROM test_nulls.hash_rel WHERE value IS NULL;
         tableoid         | value 
--------------------------+-------
 test_nulls.hash_rel_null |      
(1 row)

EXPLAIN (COSTS OFF) SELECT tableoid::REGCLASS, value
		FROM test_nulls.hash_rel WHERE value IS NOT NULL;
             QUERY PLAN             
------------------------------------
 Result
   ->  Append
         ->  Seq Scan on hash_rel_0
         ->  Seq Scan on hash_rel_1
         ->  Seq Scan on hash_rel_2
(5 rows)

EXPLAIN (COSTS OFF) SELECT tableoid::REGCLASS, value
		FROM test_nulls.hash_rel WHERE value IS NOT NULL AND value = 4;
             QUERY PLAN             
------------------------------------
 Result
   ->  Append
         ->  Seq Scan on hash_rel_2
               Filter: (value = 4)
(4 rows)

DROP TABLE test_nulls.hash_rel CASCADE;
NOTICE:  drop cascades to 4 other objects
/* range */
CREATE TABLE test_nulls.range_rel (
	id	SERIAL PRIMARY KEY,
	dt	TIMESTAMP,
	txt	TEXT);
CREATE INDEX ON test_nulls.range_rel (dt);
INSERT INTO test_nulls.range_rel (dt, txt)
SELECT g, md5(g::TEXT)
	FROM generate_series('2015-01-01', '2015-04-30', '1 day'::interval) as g;
SELECT create_range_partitions('test_nulls.range_rel', 'dt', '2015-01-01'::DATE,
	'1 month'::INTERVAL);
 create_range_partitions 
-------------------------
                       4
(1 row)

/* test creating null partition */
SELECT * FROM pathman_partition_list ORDER BY partition;
        parent        |       partition        | parttype | expr |        range_min         |        range_max         
----------------------+------------------------+----------+------+--------------------------+--------------------------
 test_nulls.range_rel | test_nulls.range_rel_1 |        2 | dt   | Thu Jan 01 00:00:00 2015 | Sun Feb 01 00:00:00 2015
 test_nulls.range_rel | test_nulls.range_rel_2 |        2 | dt   | Sun Feb 01 00:00:00 2015 | Sun Mar 01 00:00:00 2015
 test_nulls.range_rel | test_nulls.range_rel_3 |        2 | dt   | Sun Mar 01 00:00:00 2015 | Wed Apr 01 00:00:00 2015
 test_nulls.range_rel | test_nulls.range_rel_4 |        2 | dt   | Wed Apr 01 00:00:00 2015 | Fri May 01 00:00:00 2015
(4 rows)

INSERT INTO test_nulls.range_rel (dt, txt) VALUES (NULL, 'null');
SELECT * FROM pathman_partition_list ORDER BY partition;
        parent        |         partition         | parttype | expr |        range_min         |        range_max         
----------------------+---------------------------+----------+------+--------------------------+--------------------------
 test_nulls.range_rel | test_nulls.range_rel_1    |        2 | dt   | Thu Jan 01 00:00:00 2015 | Sun Feb 01 00:00:00 2015
 test_nulls.range_rel | test_nulls.range_rel_2    |        2 | dt   | Sun Feb 01 00:00:00 2015 | Sun Mar 01 00:00:00 2015
 test_nulls.range_rel | test_nulls.range_rel_3    |        2 | dt   | Sun Mar 01 00:00:00 2015 | Wed Apr 01 00:00:00 2015
 test_nulls.range_rel | test_nulls.range_rel_4    |        2 | dt   | Wed Apr 01 00:00:00 2015 | Fri May 01 00:00:00 2015
 test_nulls.range_rel | test_nulls.range_rel_null |        2 | dt   |                          | 
(5 rows)

EXPLAIN (COSTS OFF) SELECT tableoid::REGCLASS, dt
				    FROM test_nulls.range_rel WHERE dt IS NULL;
               QUERY PLAN               
----------------------------------------
 Result
   ->  Append
         ->  Seq Scan on range_rel_null
(3 rows)

SELECT tableoid::REGCLASS, dt FROM test_nulls.range_rel WHERE dt IS NULL;
         tableoid          | dt 
---------------------------+----
 test_nulls.range_rel_null | 
(1 row)

EXPLAIN (COSTS OFF) SELECT tableoid::REGCLASS, dt
				    FROM test_nulls.range_rel WHERE dt IS NOT NULL;
             QUERY PLAN              
-------------------------------------
 Result
   ->  Append
         ->  Seq Scan on range_rel_1
         ->  Seq Scan on range_rel_2
         ->  Seq Scan on range_rel_3
         ->  Seq Scan on range_rel_4
(6 rows)

EXPLAIN (COSTS OFF) SELECT tableoid::REGCLASS, dt
				    FROM test_nulls.range_rel WHERE dt IS NOT NULL AND dt > '2015-03-01'::DATE;
                        QUERY PLAN                         
-----------------------------------------------------------
 Result
   ->  Append
         ->  Bitmap Heap Scan on range_rel_3
               Recheck Cond: (dt > '03-01-2015'::date)
               ->  Bitmap Index Scan on range_rel_3_dt_idx
                     Index Cond: (dt > '03-01-2015'::date)
         ->  Seq Scan on range_rel_4
(7 rows)

EXPLAIN (COSTS OFF) SELECT tableoid::REGCLASS, dt
				    FROM test_nulls.range_rel WHERE dt IS NOT NULL OR dt > '2015-03-01'::DATE;
             QUERY PLAN              
-------------------------------------
 Result
   ->  Append
         ->  Seq Scan on range_rel_1
         ->  Seq Scan on range_rel_2
         ->  Seq Scan on range_rel_3
         ->  Seq Scan on range_rel_4
(6 rows)

EXPLAIN (COSTS OFF) SELECT tableoid::REGCLASS, dt
				    FROM test_nulls.range_rel WHERE dt IS NULL OR dt > '2015-03-01'::DATE;
                        QUERY PLAN                         
-----------------------------------------------------------
 Result
   ->  Append
         ->  Bitmap Heap Scan on range_rel_3
               Recheck Cond: (dt > '03-01-2015'::date)
               ->  Bitmap Index Scan on range_rel_3_dt_idx
                     Index Cond: (dt > '03-01-2015'::date)
         ->  Seq Scan on range_rel_4
         ->  Seq Scan on range_rel_null
(8 rows)

EXPLAIN (COSTS OFF) SELECT tableoid::REGCLASS, dt
				    FROM test_nulls.range_rel WHERE dt IS NULL AND dt > '2015-03-01'::DATE;
        QUERY PLAN        
--------------------------
 Result
   One-Time Filter: false
(2 rows)

DROP SCHEMA test_nulls CASCADE;
NOTICE:  drop cascades to 7 other objects
DROP EXTENSION pg_pathman CASCADE;
